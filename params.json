{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Simon for Android with Processing","body":"# PGL: APSimon, Simon para Android sobre Processing\r\n\r\n***\r\n\r\n## Acerca de este documento\r\n\r\nLa presente documentación recoge, en líneas generales, el resultado final del\r\nproyecto de «Desarrollo de Juegos en 2D» de la asignatura de «Programación\r\nMultimedia y Dispositivos Móviles» (tutorizada por D. Rafael Ascanio Perera) en\r\nel [IES El Rincon](http://ieselrincon.org/), llevado a cabo durante el curso\r\nacadémico 2012/2013 del Ciclo de Formación Profesional «Desarrollo de\r\nAplicaciones Multiplataforma».\r\n\r\nEn algunas ocasiones se hacen referencias a «la documentación anterior» o\r\n«dosier anterior» para referirse al primer documento entregado para el mismo\r\nproyecto y misma asignatura, en el cual se hacía una descripción y\r\nplanificación/previsión de los objetivos del mismo.\r\n\r\n***\r\n\r\n\r\n## El proyecto\r\n\r\n### La idea inicial\r\n\r\nImplementar el conocido y popular juego de los 80\r\n[«Simon»](http://en.wikipedia.org/wiki/Simon_(game%29), creado por Ralph Baer\r\nen 1978, para la plataforma Android haciendo uso del lenguaje de programación\r\n[«Processing»](http://processing.org), distribuido bajo licencia GNU/GPL.\r\n\r\n### Objetivo\r\n\r\nEl propósito de la creación de este software no ha ido más allá de los fines\r\ndidácticos, tal y como se declaraba en el apartado «alcance» del documento\r\npresentado con anterioridad a éste [] centrándose más en la parte técnica que\r\nen la visión comercial.\r\n\r\n### Alcance\r\n\r\nEl alcance de este proyecto no dista mucho del propuesto inicialmente: servir\r\nde iniciación al desarrollo de software haciendo uso de distintas técnicas y\r\nherramientas.\r\n\r\n## Descripción general\r\n\r\n### Perspectiva del proyecto\r\n\r\nSi bien la perspectiva inicial del proyecto se centraba en la interacción del\r\nusuario con la pantalla táctil de su terminal móvil, finalmente ésta ha sido\r\nrelegada a un segundo plano para centrarse más, a nivel de desarrollo, en la\r\nestructura y codificación del mismo.\r\n\r\n### Funciones de la aplicación\r\n\r\nLa función principal de la aplicación no es otra que generar una secuencia\r\naleatoria de N elementos en base a 4 posibles que, posteriormente, presentará\r\nal usuario de forma visual y acústica con el fin de que éste sea capaz de\r\nreproducirla, incrementándose la longitud de la misma en 1 elemento con cada\r\nacierto del usuario.\r\n\r\n### Estructura de la aplicación\r\n\r\nPara conseguir la función descrita se ha estructurado el código de la\r\naplicación de acuerdo a:\r\n\r\n  * Programación Orientada a Objetos: a excepción del fichero principal de la\r\n  aplicación, que por imposición ha de tener el mismo nombre que el\r\n  directorio y ser estructurado, el resto de ficheros de la aplicción se\r\n  corresponde con «objetos» que representan los distintos «actores» o\r\n  «entidades» que dan forma a la misma, y que son:\r\n\r\n    * Game, que representa al juego en sí.\r\n    * Board, para la construcción del tablero.\r\n    * Board_Button, para instanciar cada\r\n    uno de los 4 «botones» que se corresponden con cada elemento de la\r\n    secuencia, representado por un color y un sonido\r\n    * Player, que se corresponde con el jugador.\r\n    * VerticalLayout, encargado de la disposición de todos los elementos\r\n    gráficos, al menos para la orientación vertical\r\n    * MediaPlayer, que vendría a ser una «wrappe» de las librerías de sonido,\r\n    según corresponda uno u otra dependiendo del sistema/máquina virtual en\r\n    el que se está ejecutando. [Finalmente no termina de funcionar del todo bien]\r\n    * SequenceThread. Se trata de un objeto «especial» que representa un hilo\r\n    de ejecución y que es necesario para poder mostrar los elementos de la\r\n    secuencia «iluminándose», ya que de lo contrario no habría tiempo de verlos\r\n    puesto que el método «draw()» de Processing «dibuja» la salida una vez que ha\r\n    finalizado toda la ejecución del código que hay dentro del mismo.\r\n\r\n  * Utilización de patrones de diseños: concretamente dándole un enfoque MVC\r\n  (Modelo Vista Controlador), sin analizar más profundamente qué otros\r\n  patrones se podían haber aplicado, para así mantener, de alguna forma, el\r\n  código más limpio y ordenado. \r\n\r\n    * Controlador: apsimon.pde, el «punto de entrada» de la aplicación.\r\n    Pensamos también que, en cierta manera e implícitamente, se está usando aquí el\r\n    patrón Singleton.\r\n\r\n    * Modelos: a pesar de que no hay persistencia, nuestros modelos se podrían\r\n    corresponder con Game, Player Board y BoardButton, si bien estos dos últimos\r\n    pudieran quedar un poco «descolgados» de este enfoque\r\n\r\n    * Vista: aquí tenemos a VerticalLayout y, si los hubiera, todas las otras\r\n    representaciones gráficas de la aplicación. Sin ir más lejos, la inexistente\r\n    «HorizontalLayout». En este punto cabe destacar que debería existir, quizás\r\n    y dado que al fin y al cabo Prossecing no deja apoyarse en Java, una Interfaz\r\n    «Layout» encargada de definir qué métodos ha de implementar todo «XYZLayout»\r\n    existente.\r\n\r\n    * Se nos quedarían fuera el hilo (SequenceThread) y el «wrapper» de audio\r\n    (MediaPlayer) ya que ambos tienen algo de «vista» (a pesar de que para el caso\r\n    de media player la representación sea acústica) y de «modelo», pues de alguna\r\n    forman trabajan con datos (elementos de la secuencia el primero y ficheros de\r\n    audio el segundo) a la vez que los representan.\r\n\r\nAunque se trata de pequeños aspectos más funcionales que estructurales, cabe anotar que\r\n\r\n  * La aplicación está, de forma general, en modo «noLoop()», para evitar un\r\n  uso innecesario del procesador.\r\n  * La excepción a lo anterior la encontramos en el hilo «Sequence Thread», que\r\n  precisamente hace uso de «loop()» mientras está «mostrando» la secuencia.\r\n  * Si bien a posteriori hemos sabido, por la aportación de un compañero en\r\n  clase, de la posibilidad de usar «sleep» dentro de un hilo, hemos decidido\r\n  dejar el código que hacía esta función (almacenar el tiempo en ejecución y\r\n  esperar a que éste se hubieran incrementado en X).\r\n  * Todas las llamadas a «redraw()» se hacen en el controlador (apsimon.pde)\r\n\r\n  \r\n### Presentación de la aplicación\r\n\r\nRespecto a lo recogido en el dosier anterior, la presentación de la aplicación\r\nse ha quedado sólo en «layout» vertical, manteniéndose la disposición propuesta\r\npara el mismo, incluyendo la subdivisión de la superficie disponible en una\r\n«rejilla» o grid imaginario para la distribución uniforme de los elementos\r\nindependientemente del área de dicha superficie.\r\n\r\n\r\nComo se comentaba en el punto anterior, la idea sería disponer a nivel de\r\nclases de una Interfaz que defina una representación abtracta del lienzo para\r\nque sea extendida por todas y cada una de las representaciones que se deseen\r\nimplementar.\r\n\r\n\r\n### Recursos utilizados durante el desarrollo\r\n\r\nAdemás de, obviamente, el lenguaje de programación utilizado (Processing), se\r\nha hecho uso de los siguientes recursos\r\n\r\n  * La librería [APWidgets](http://code.google.com/p/apwidgets/), para el trabajo\r\n  con el audio y algunos otros elementos en Android.\r\n  * La librería [Minim](http://code.compartmental.net/tools/minim/), para el\r\n  trabajo con audio haciendo uso de JavaSound API.\r\n  * La clase\r\n  [Random](http://docs.oracle.com/javase/6/docs/api/java/util/Random.html) para\r\n  la generación aleatoria de la secuencia.\r\n  * [Git](http://git-scm.com/) para el trabajo en grupo footnote:[En muchos casos\r\n  se está y se estará trabajando en un solo equipo, por lo que la información\r\n  del «commiter» no está vinculada al trabajo/peso real de cada miembro del\r\n  equipo], control de versiones y «sincronización» con el repositorio alojado\r\n  en GitHub.\r\n  * [Github](http://github.com) para alojar el repositorio remoto del proyecto.\r\n\r\n### Otros recursos\r\n\r\n  * [SoundCloud](http://soundcloud.com) y [SoundGator](http://www.soundgator.com/)\r\n  para la búsqueda y elección de las pistas de audio que sean necesarias.\r\n  * [Asciidoc](http://www.methods.co.nz/asciidoc/) para la generación de este\r\n  documento.\r\n  * [Moqups](https://moqups.com/) para la creación de mockups\r\n  * [Wiki de Processing](http://wiki.processing.org/w/Main_Page), para información técnica.\r\n  * [OpenProcessing](http://www.openprocessing.org), como «fuente de\r\n  conocimiento» (aunque finalmente sólo se ha codigo el código que general el\r\n  background, haciendo uso de la función «noise()»)\r\n  * [LearningProcessing](http://www.learningprocessing.com) para visualizar ejemplos con enfoques\r\n  orientados a objeto (POO).\r\n\r\n## Estado actual\r\n\r\nA pesar de tratarse de una aplicación experimental y no terminada, centrada más\r\nen el aprendizaje a nivel de desarrollo que en el acabado final de cara al\r\nusuario, se dispone a día de, básicamente, la posibilidad de mostrar una\r\nsecuencia y recoger la recreada por el usuario, aumentando el nivel en caso de\r\nacierto.\r\n\r\n### Presentación\r\n\r\nA nivel de presentación se dispone a día de hoy de un layout vertical que nos muestra \r\n\r\n  * Nombre/Rótulo de la aplicación\r\n  * Información del nivel actual (de 1 en adelante).\r\n  * Información de la puntuación actual (de 0 en adelante, siendo un\r\n  «acumulador» de los aciertos, contados éstos en base a la longitud de la\r\n  secuencia).\r\n  * Un «tablero», compuesto de los 4 elementos posibles de la secuencia, con el\r\n  que interactuar a fin de conseguir el objetivo.\r\n  * «Pantalla de inicio», que no es más que una leyenda en la pantalla con las\r\n  instrucciones para comenzar (hacer click)\r\n  * «Pantalla de Game Over», en la que se muestra información de nivel y puntos\r\n  obtenidos y la opción para volver a empezar\r\n\r\n### Fallos conocidos\r\n\r\nA pesar de los distintos intentos realizados, a la fecha actual y con el tiempo\r\ndedicado, no se ha conseguido tener una aplicación que se comporte de forma\r\nestable tanto en Android como en otro sistema operativo sobre una máquina\r\nvirtual de Java. Esto es así principalmente por incompatibilidades entre\r\nlibrerías, lo que no nos ha permitido poder incluirlas todas para\r\nposteriormente usar unas u otras según el soporte en el que se esté ejecutando,\r\nque era el objetivo de, por ejemplo, «media_player.pde».\r\n\r\nEl sonido, en Java, sólo se reproduce la primera vez y, en algunas otras\r\nocasiones, de forma aleatoria. Esto podría ser porque se necesite un objeto\r\n«AudioPlayer» para cada sonido que se vaya a reproducir, si bien es cierto que\r\nse hicieron algunas pruebas sin éxito.\r\n\r\nAdemás, en las últimas pruebas han ocurrido ocasioalmente desbordamiento de\r\narray (ArrayIndexOutOfBoundsException) al mostrar la secuencia propuesta al\r\nusuario. Debe estar relacionado con algunos de los últimos cambios, pero aún no\r\nlo hemos localizado.\r\n\r\n### Mejoras a corto plazo\r\n\r\nA pesar de la constante «obsesión» en trabajar de cara a la obtención de un\r\ncódigo limpio, ordenado y con cierta «calidad», creemos que unas tempranas\r\nrefactorizaciones podrían ser\r\n\r\n  * Utilizar variables/constantes para el cálculo de la diferencia de tiempo\r\n  (millis() - lastTime < DELAY), para el frameRate, tamaños de textos...\r\n  * Utilizar el «coding style» o «code conventions» de Java, para ser más\r\n  homogéneos y ofrecer un código «más legible» a programadores del lenguaje.\r\n  * Utilizar Thread.sleep (manteniendo el DELAY en variable) a fin de reducir\r\n  así el código de SequenceThread.\r\n  * Mejorar la estabilidad y fluidez.\r\n\r\n### Mejoras a medio plazo\r\n\r\nA medio plazo, la cantidad de mejoras que se podrían hacer serían casi\r\ninnumerables, pero listando las más importantes tendríamos\r\n\r\n  * Dar soporte al layout horizontal.\r\n  * Implementar una pantalla inicial.\r\n  * Implementar las pantallas de cambio de nivle.\r\n  * Mejorar la interfaz gráfica (usando elementos 3D, brillo, iluminación...)\r\n  * Añadir niveles de dificultad (por ejemplo, con un límite de tiempo o\r\n  decrementando el DELAY de la secuencia con el paso de nivel).\r\n  * Añadir un top de «mejores puntuaciones».\r\n  * Añadir preferencias de usuario.\r\n  * Posibilidad de multijugador («challenge», duelos).\r\n  * ...","tagline":"","google":"*  * * * "}